var tipuesearch = {"pages": [
     {"title": "introduction", "text": "     The pasc is a cross-platform command line tool that is intended to help with the development process of Free Pascal / Lazarus projects, assisting during development, testing, build and documentation.    It allows you to create projects, add tests, add automation to documentation, in addition to providing a watch command to monitor the projects folder for changes and thereby trigger the build and test report process.    An interesting feature is the ease with which a new project can be configured to work with vscode providing configuration files for build, to run tests, and even for watch project folder and to trigger build and tests.    Commands              Add    Build    Clean    Help    Install    New    Test    Version    Watch          Requirements      This tool was tested with FPC 3.2.2 and Lazarus 2.2.2, but it may work with other versions. Should work under Linux, MacOS and Windows.    To work with the project using vscode you will going to need the following requirements:            a vscode extension that provides code completion, syntax check, etc for FreePascal, OmniPascal is a good one.    a vscode extension to debug your project, the launch.json file generated by pasc is using Free Pascal (fpc) Debugger extension, but you can change it to one of your preference    lazbuild should be in the path, pasc uses it to build the projects and the tests projects. You can find lazbuild on Lazarus tools sub folder.          Optional items that can improve the experience:            vscode should be in the path. Some examples might suggest to type &quot;code .&quot; to open the editor directly from the prompt.    git command line should be in the path.    Boss a dependency manager tool.    Pasdoc should be in the path, pasc uses it to build documentation.    Powershell installed even for Linux and MacOS. It is necessary to run script to generate project documentation.          License      pasc is free and open-source software licensed under the MIT License.                  Next Install            Overview", "tags": "", "url": "introduction.html"},
     {"title": "install", "text": "     Pasc is a standalone executable application and it is simple to install.    Manual installation      From the releases page download a &quot;pasc-...zip&quot; file according to your platform. Extract its contents and run the following command:       ./pasc install        Pasc will install itself on user's home folder creating a subfolder named .pasc and adding it to the path to make pasc visible when using the terminal app. It may be necessary to restart the terminal app for the changes take effect. Type pasc from the terminal app to check if it is working.    Build it from the sources      You may clone the repo and build it. Open a terminal and choose a folder to clone the repo and type the following commands:          git clone https://github.com/leandro-lprsoft/pasc.git  cd pasc  lazbuild pasc.lpi --build-mode=release  ./pasc install        Note You may need to run the command with elevation of privilege for MacOS or Linux.     Test pasc      To see if pasc is working type the following:          pasc help new        You should see an output like this:          pasc version 1.0.6    Usage: pasc new &lt;project file name&gt;    Creates a new free pascal program.  From the current path create a subfolder with the given project name,  initialize git, initialize the boss dependency manager, create build  and debug support files for use with vscode and create a project based  on a simple free pascal template.  Ex: pasc new &lt;project name>                      Next Quick start            Install", "tags": "", "url": "install.html"},
     {"title": "quickstart", "text": "     Assuming that pasc is already installed you can continue in this section.    Create a new project      Create a new project using pasc, open a terminal, navigate to your project path and run the following command:          pasc new helloWorld  code helloWorld        This command will create a subfolder named helloWorld and will create the project structure inside it. The second line calls vscode and opens the new folder that was created. Requires that vscode to be in the path.    Checking the project folder structure      You will notice that a project strucuture was created similar to this on below:          .  ├───.vscode  │   ├───launch.json  │   └───tasks.json  ├───src  ├───.gitignore  ├───boss-lock.json  ├───boss.json  ├───helloWorld.lpi  └───helloWorld.lpr        We have the project file and also a lazarus project file that makes easy to build the project. There are files to use vscode too with predefined tasks and a suggested launch entry to debug your app. Please check vscode requirements on install.    The folder was initialized as a git repository too and one suggested file as .gitignore based on pascal language.    The boss dependency manager was also initialized, so to install new dependencies using it is possible using the command &quot;boss install&quot;, for more information check https://github.com/HashLoad/boss. If you don't want to use boss just delete the filse boss-lock.json and boss.json from the root path of the project.    Type some code      If you ran the &quot;code helloWorld&quot; command, there should be a vscode instance with the project open. Activate vscode or just open the project folder in a new instance.    Open the helloWorld.lpr project file and enter the following code:          WriteLn('Hello, world!');        If the prerequisites for using vscode are satisfied as described in install, you should be able to use the build task (ctrl + shift + b, or the appropriate combination depending on the platform).    The pasc tool doesn't compile the project it just creates tasks for it, and when it does it's just calling the Lazarus build tool for that: lazbuild.    You can verify that the application has been compiled successfully by simply running the following command from a vscode terminal:          ./helloWorld        Using the vscode tasks      Some predefined tasks were created but only the build and launch for debug should work as long as the requirements for vscode operation are met.    Testing and documentation tasks require the existence of test projects and scripts for documentation automation that can be added by pasc via the add &ndash;tests &ndash;docs command. See the Add Command section on how to add tests and documentation to the project.                  Next Add Command            Quick start", "tags": "", "url": "quickstart.html"},
     {"title": "commandadd", "text": "     Description      This command has two options: one to add a test project to the main project and another option to add automatic code documentation capability to the project.    Example to add both tests and docs to the project:       pasc add --tests --docs        This command must be run from the current directory of a FreePascal/Lazarus project to work. Here's how each option works:    --tests      Use the project from the previous page quickstart as a base to try out the features of this page.    To add a test project to the project, do the following: with the project folder open on vscode, open a terminal session and from the project root execute the following command:          pasc add --tests        This command will add a test project by creating a subfolder named tests and adding a basic test project template with some example cases. We can see that our project structure has been modified a bit to something like this:          ./HelloWorld  ├───.vscode  │   ├───launch.json  │   └───tasks.json  ├───src  ├───tests  │   ├───TestHelloWorld.lpi  │   ├───TestHelloWorld.lpr  │   └───TestCaseHelloWorld.pas  ├───.gitignore  ├───boss-lock.json  ├───boss.json  ├───helloWorld.lpi  └───helloWorld.lpr        Open TestCaseHelloWorld.pas file, there are three tests in this unit, one test that passes, one that fails and one that causes a memory leak.    These tests are like this to demonstrate how the pasc test report looks like. The idea behind a different report is to provide a quick identification of tests that failed for some reason. And this is done through the use of colors and alignment and with the consolidation of test information and possible memory leaks in a single report.    Now our tests task can be run with a test project available, you can now run a vscode task &quot;pasc: run tests&quot;, it depends on &quot;lazbuild: build tests&quot;. You should see an output similar to this:        In this image we have a first block that is the output of the pascal compiler and in the second block we have the output generated by pasc with the summary of the execution of all tests. We can see that there is a test failing: TTestCaseHelloWorld.TestThatFails, you can ctrl + click on the file name to check the respective line for that test. Another problem case is a leak included on purpose in TTestCaseHelloWorld.TestThatLeaks, you can also ctrl + click on the file to locate the line of code with the problem.    Try to fix the problems by commenting out the line of code from the test that fails and uncommenting the LObject.Free line from the test that leaks. Run the tests again and you will see something like the output below:        We can see that all tests are passing now. Therefore, consolidating the test results with a summary of possible leaks gives us productivity to address problems as soon as they become visible. There are more features that can be combined with the pasc test command such as the watch command.    --docs      Using the same project run the following command to add features that aim to facilitate the creation of project documentation:          pasc add --docs        This command will add a &quot;docs&quot; subfolder containing resources to help generate a site containing the project's code documentation. Check the folder structure below:          ./HelloWorld  ├───.vscode  │   ├───launch.json  │   └───tasks.json  ├───docs  │   └───generate  │       ├───build.ps1  │       ├───custom.css  │       ├───introduction.txt  │       └───quickstart.txt  ├───src  ├───tests  │   ├───TestHelloWorld.lpi  │   ├───TestHelloWorld.lpr  │   └───TestCaseHelloWorld.pas  ├───.gitignore  ├───boss-lock.json  ├───boss.json  ├───helloWorld.lpi  └───helloWorld.lpr        Inside the docs folder, a generate folder was created containing inputs to generate the project documentation. It is required that pasdoc must be installed and accessible through the environment path. To generate the documentation, just run the &quot;pasdoc: build documentation&quot; task or the following command in the project's root folder:          docs/generate/build.ps1        This script will call the pasdoc which in turn will populate the docs folder with the pages that compose the site with the documentation. This site can be published, for example, using the github pages feature by choosing the docs folder as the documentation source.    If you have the vscode extension Live Server you can just right click with the mouse on file index.html and choose &quot;Open with live server&quot;, this will make the browser display the documentation site. Check that the style css used is the same as pasc itself, which just uses a customized version of the style that comes with pasdoc. Feel free to change custom.css file.    There are two files in the generate folder: introduction.txt which contains the project overview and was built using the tags provided by pasdoc, and the quickstart.txt file which, as its name says, aims to transmit to the user a quick way to start use the project. These files are informed to pasdoc, inside the script docs/generate/build.ps1 through specific options, any new file must be informed through the option &quot;&ndash;additional&quot;. Another important point of the script is the Set-NavigationMenuOrder function responsible for organizing the order of menu items in all documentation files. This is done so that additional menu items always appear before the reference documentation (code documentation).                  Next Build Command            Add", "tags": "", "url": "commandadd.html"},
     {"title": "commandbuild", "text": "     Description      This command just calls lazbuild to perform the build, if you want to compile the project manually, we recommend using the lazbuild tool or the fpc compiler itself for that.    The reason behind the existence of this command along with pasc is only for the implementation of the watch command.    Example:       pasc build HelloWorld.lpi                      Next Clean Command            Build", "tags": "", "url": "commandbuild.html"},
     {"title": "commandclean", "text": "     Description      This command only deletes the lib and backup subfolders found recursively from the current directory. The user is asked for confirmation for each folder found to be removed, to avoid this question the option &ndash;force can be passed as an argument.    Sometimes it is important to clean the lib directory to eliminate the build cache of some units of the project helping to execute a clean build for the next run.    Note There may be a need for more thorough cleaning that the Lazarus IDE provides from the Run/Clean up and Build menu.     Example:       pasc clean        Example to clean without asking for confirmation:       pasc clean --force                      Next Help Command            Clean", "tags": "", "url": "commandclean.html"},
     {"title": "commandhelp", "text": "     Description      The help command is called by default when no argument, parameter is passed to pasc. The first information displayed is the tool version, followed by a general usage description.    The general purpose description displays a tool usage syntax from the command line, a short description of the tool and a list of commands if any. In addition to this usage, it is possible to obtain a detailed description of a specific command by passing it as an argument to the help command.    Example:       pasc help        Example to get help for new command:       pasc help new                      Next Install Command            Help", "tags": "", "url": "commandhelp.html"},
     {"title": "commandinstall", "text": "     Description      Installs pasc in the user's home folder, for that it creates a subfolder called .pasc and copies the executable itself to that folder. Also, add the new folder to the path environment variable so that you can call pasc from any folder.    NoteIt is recommended to restart our terminal session for the addition to the path to take effect. For MacOS you need to use elevation before running this command.    Example:       ./pasc install                      Next New Command            Install", "tags": "", "url": "commandinstall.html"},
     {"title": "commandnew", "text": "     Description      The new command was discussed in the Quick start section, here we will comment on the details of its operation.    Example:       pasc new myproject        This command aims to quickly create a FreePascal/Lazarus project surrounded by add-ons that can contribute to a better direction of the project in terms of organization and tools used during development, implementation/test execution, versioning, dependency management and documentation. For this, the created project contains the following items:    Folder structure      Creates a project folder structure starting with the folder with the project name itself, the user does not need to create a folder for the project. Requires that the folder does not exist for the command to run.    You will notice that a project strucuture was created similar to this on below:          .  ├───.vscode  │   ├───launch.json  │   └───tasks.json  ├───src  ├───.gitignore  ├───boss-lock.json  ├───boss.json  ├───myproject.lpi  └───myproject.lpr        Project template      Creates FreePascal/Lazarus project files based on a simple template. The .lpr code refers to a simple console program while the .lpi project file allows it to be working in the Lazarus IDE. The project can also be opened in vscode as long as the prerequisites defined in Overview are installed.    vscode files      Creates support files to work with vscode, leaving it preconfigured for build, debug, tests and watch. The following items are covered:            lazbuild: build =&gt; task to build the main project    lazbuild: build tests =&gt; task to build the unit tests project*    pasc: run tests =&gt; task to build the unit tests project* and also run the tests using pasc to display the results    pasc: watch, build tests and run tests =&gt; task to start pasc watch** command    pascdoc: build documentation =&gt; task to start pascdoc*** to build documentation    Debug =&gt; launch command for debug the main project using fpDebug extension    Debug Tests =&gt; launch command for debug a specific test using fpDebug extension          * only works if a test project exists in tests subfolder.    ** check Watch command for more information.    *** only works if the command pasc add &ndash;docs was executed for the project    Git      Initialize the project folder as git repository with a standard .gitignore file for pascal projects. Requires git to work, if it is not present just a warning is printed by pasc.    Boss      It initializes the boss in the project folder allowing it to install dependencies easily, it also allows the project to be a new dependency so that others who have the boss can install it easily, but this is not mandatory. To learn more about: follow the boss link.                  Next Test Command            New", "tags": "", "url": "commandnew.html"},
     {"title": "commandtest", "text": "     Description      The purpose of this command is to display an aligned and colored output to make it easier to follow the test results. For it to work, there must be a previously compiled test project in a subfolder called &quot;tests&quot;. This project needs to be of type fpcunit framework. If the project was created with the command new from pasc, and if the test project was created with the command add &ndash;tests from pasc, then these requirements must already be met.    This command accepts a &quot;&ndash;test-case&quot; option that can be given the name of a test class (suite) or the name of a specific method so that it is possible to reduce the focus of what is currently being tested.    Example:Another important feature is the output about possible memory leaks reported by the project at the end of its execution.          pasc test        Check the output for pasc as an example:        In the example above, we can see the execution time for each test, we can see an OK in green and the name of the test. We can see an example of a test that fails in section Add Command, and also a memory leak too.    Example for a single suite:       pasc test --test-case=TTestUtilsShell        Check the output for pasc TTestUtilsShell class as an example:        We can see a shorter output with tests results only for the selected class.    Leak report      The leak report, when there is an item, displays information about the source of the resource that caused the leak, indicating the code line and the respective code file, if you are using vscode, you can &quot;ctrl click&quot; or &quot;cmd click&quot; to navigate to the line of code in question. This possibility is demonstrated through examples in the quick start section.    In order for information about memory leaks to be extracted from the execution of the test project executable, some requirements must be met (They are provided automatically by the add &ndash;tests command):    1. The .lpi project configuration file is marked with the option to use the HeapTrace unit.    2. A code has been added that defines the output of trace information for the heap.trc file that will be generated in the &quot;tests&quot; folder after the tests are finished. It is based on this file that pasc generates the output of possible leaks. Check the procedure that was added to the test project:          procedure InitializeHeapFileName;  var    HeapFileName: string;  begin    {$IF DECLARED(UseHeapTrace)}    HeapFileName := ConcatPaths([ExtractFilePath(ParamStr(0)), 'heap.trc']);    if FileExists(HeapFileName) then      DeleteFile(HeapFileName);    SetHeapTraceOutput(HeapFileName);    {$ENDIF}  end;        Note For some reason, some platforms supported by FreePascal are able to indicate the source code line/file of the leak, but others can only say that a leak has occurred. As of the time of writing this documentation, for platforms aarch64/darwin and aarch64/linux are not displaying the leak source line of code/file.     Tasks      It's worth mentioning the vscode tasks configured to run the test project, as well as the entry in the launch.json file that allows debugging the test project targeting a specific test.    pasc: run tests      This task calls pasc test as shell, but it depends on task lazbuild: build tests, so every time you run it the test project is built to provide a updated result.    Debug tests      This an entry on launch.json file, you can choose this debug item as the start point for debug, this allows to debug an specific test case.    Watch command      Test command is also used by another command called watch that will be covered in the watch section.                  Next Version Command            Test", "tags": "", "url": "commandtest.html"},
     {"title": "commandversion", "text": "     Description      This command displays the version of pasc.    Example:       pasc version                      Next Watch Command            Version", "tags": "", "url": "commandversion.html"},
     {"title": "commandwatch", "text": "     Description      Command that watches the directory for changes and executes ...    Example:       pasc watch run         Output:  Watch", "tags": "", "url": "commandwatch.html"},
     {"title": "Command.Add", "text": "   ", "tags": "", "url": "Command.Add.html"},
     {"title": "Command.Add.AddCommand", "text": "   ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ", "tags": "", "url": "Command.Add.html#AddCommand"},
     {"title": "Command.Add.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Add.html#Registry"},
     {"title": "Command.Build", "text": "   ", "tags": "", "url": "Command.Build.html"},
     {"title": "Command.Build.BuildCommand", "text": "   ABuilder Command builder that will provide the output callback to print info about the command execution ABuilder Command builder that will provide the output callback to print info about the command execution ", "tags": "", "url": "Command.Build.html#BuildCommand"},
     {"title": "Command.Build.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Build.html#Registry"},
     {"title": "Command.Build.FindProject", "text": "       AProjectDir Folder to find the lazarus project AProjectFile Project file specified. AProjectDir Folder to find the lazarus project AProjectFile Project file specified. ", "tags": "", "url": "Command.Build.html#FindProject"},
     {"title": "Command.Clean", "text": "   ", "tags": "", "url": "Command.Clean.html"},
     {"title": "Command.Clean.CleanCommand", "text": "   ABuilder Command builder that will provide the output callback to print info about the command execution ABuilder Command builder that will provide the output callback to print info about the command execution ", "tags": "", "url": "Command.Clean.html#CleanCommand"},
     {"title": "Command.Clean.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Clean.html#Registry"},
     {"title": "Command.Clean.AnsweredAll", "text": "   ", "tags": "", "url": "Command.Clean.html#AnsweredAll"},
     {"title": "Command.Install", "text": "   ", "tags": "", "url": "Command.Install.html"},
     {"title": "Command.Install.InstallCommand", "text": "   ABuilder Instance o the builder that will be use to output instructions to user about the installation status ABuilder Instance o the builder that will be use to output instructions to user about the installation status ", "tags": "", "url": "Command.Install.html#InstallCommand"},
     {"title": "Command.Install.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Install.html#Registry"},
     {"title": "Command.New", "text": "   ", "tags": "", "url": "Command.New.html"},
     {"title": "Command.New.NewCommand", "text": "   ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ", "tags": "", "url": "Command.New.html#NewCommand"},
     {"title": "Command.New.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.New.html#Registry"},
     {"title": "Command.Test", "text": "   ", "tags": "", "url": "Command.Test.html"},
     {"title": "Command.Test.TestCommand", "text": "   ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ", "tags": "", "url": "Command.Test.html#TestCommand"},
     {"title": "Command.Test.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Test.html#Registry"},
     {"title": "Command.Test.GetTestExecutable", "text": "   ABuilder Command builder of the main application that will be used to output info about the existence of the test project and whether it is valid. ABuilder Command builder of the main application that will be used to output info about the existence of the test project and whether it is valid. ", "tags": "", "url": "Command.Test.html#GetTestExecutable"},
     {"title": "Command.Watch", "text": "( This unit contains procedures for setting up and executing a watch command in the current directory. If there are changes to files in that directory, specified commands are executed. &lt;/sumamry&gt;   ", "tags": "", "url": "Command.Watch.html"},
     {"title": "Command.Watch.WatchCommand", "text": "   ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ABuilder Command builder of the main application that will be used to output user instructions about the execution state of this command. ", "tags": "", "url": "Command.Watch.html#WatchCommand"},
     {"title": "Command.Watch.Registry", "text": "   ABuilder Command builder of the main application that will be used to registry the command. ABuilder Command builder of the main application that will be used to registry the command. ", "tags": "", "url": "Command.Watch.html#Registry"},
     {"title": "Command.Watch.RunUserCommandAsRequested", "text": "       AFile Filename that triggered the action change. AEvent The event that triggered this procedure. AFile Filename that triggered the action change. AEvent The event that triggered this procedure. ", "tags": "", "url": "Command.Watch.html#RunUserCommandAsRequested"},
     {"title": "Command.Watch.RunWatcherCallback", "text": "   ", "tags": "", "url": "Command.Watch.html#RunWatcherCallback"},
     {"title": "Command.Watch.CommandWatchTimeout", "text": "   ", "tags": "", "url": "Command.Watch.html#CommandWatchTimeout"},
     {"title": "pasc", "text": "   ", "tags": "", "url": "pasc.html"},
     {"title": "Utils.Interfaces", "text": "   ", "tags": "", "url": "Utils.Interfaces.html"},
     {"title": "Utils.Interfaces.IPathWatcher", "text": "ignore files with the specified extension    ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html"},
     {"title": "Utils.Interfaces.IPathWatcher.Path", "text": "   APath Path that will be monitored APath Path that will be monitored ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html#Path"},
     {"title": "Utils.Interfaces.IPathWatcher.Ignore", "text": "       AIgnoreKind Kind of item to be ignored by the watcher AItems An array containing strings to be ignored according to AIgnoreKind AIgnoreKind Kind of item to be ignored by the watcher AItems An array containing strings to be ignored according to AIgnoreKind ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html#Ignore"},
     {"title": "Utils.Interfaces.IPathWatcher.Timeout", "text": "   ATime Number of milliseconds to set the maximum timeout. ATime Number of milliseconds to set the maximum timeout. ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html#Timeout"},
     {"title": "Utils.Interfaces.IPathWatcher.Run", "text": "     )  AProc A procedure that will be called after a change AProc A procedure that will be called after a change ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html#Run"},
     {"title": "Utils.Interfaces.IPathWatcher.Start", "text": "    ", "tags": "", "url": "Utils.Interfaces.IPathWatcher.html#Start"},
     {"title": "Utils.Interfaces.TWatcherEvent", "text": "    weFirstRun    weFileChanged  The first run of the application  weTimeout  The file has changed  weNoChange  The file has been deleted ", "tags": "", "url": "Utils.Interfaces.html#TWatcherEvent"},
     {"title": "Utils.Interfaces.TWatcherRunCallback", "text": "No changes were detected        AFile The file that triggered the event. It will be empty for first run and no change. AEvent The event that triggered this procedure. AFile The file that triggered the event. It will be empty for first run and no change. AEvent The event that triggered this procedure. ", "tags": "", "url": "Utils.Interfaces.html#TWatcherRunCallback"},
     {"title": "Utils.Interfaces.TIgnoreKind", "text": "    ikStartsText    ikFolder  itens of any kind that starts with the text specified  ikFile  ignore folders with the specified name  ikExtension  ignore files with the specified name ", "tags": "", "url": "Utils.Interfaces.html#TIgnoreKind"},
     {"title": "Utils.IO", "text": "   ", "tags": "", "url": "Utils.IO.html"},
     {"title": "Utils.IO.GetFileContent", "text": "    File name that will have its content returned )    ", "tags": "", "url": "Utils.IO.html#GetFileContent"},
     {"title": "Utils.IO.GetJsonFileContentWithOutComments", "text": "    File name that will have its content returned )    ", "tags": "", "url": "Utils.IO.html#GetJsonFileContentWithOutComments"},
     {"title": "Utils.IO.SaveFileContent", "text": "       AFileName Target file name, the file name will be replaced AContent Content string that will be saved on the file AFileName Target file name, the file name will be replaced AContent Content string that will be saved on the file ", "tags": "", "url": "Utils.IO.html#SaveFileContent"},
     {"title": "Utils.IO.FindInCodeFile", "text": "       ACodeFile Should have have the file contents already loaded. AText The text to be found ACodeFile Should have have the file contents already loaded. AText The text to be found ", "tags": "", "url": "Utils.IO.html#FindInCodeFile"},
     {"title": "Utils.IO.FindFile", "text": "       ACurrentDir Folder from which to search including subfolders AFileName Name of the file to be searched ACurrentDir Folder from which to search including subfolders AFileName Name of the file to be searched ", "tags": "", "url": "Utils.IO.html#FindFile"},
     {"title": "Utils.IO.FindProjectFile", "text": "   ABuilder Command builder of the main application that will be used to output user instructions or to iteract with the user. ABuilder Command builder of the main application that will be used to output user instructions or to iteract with the user. ", "tags": "", "url": "Utils.IO.html#FindProjectFile"},
     {"title": "Utils.IO.FindSourceFile", "text": "   AProjectDir Project path from which to search AProjectDir Project path from which to search ", "tags": "", "url": "Utils.IO.html#FindSourceFile"},
     {"title": "Utils.Leak", "text": "   ", "tags": "", "url": "Utils.Leak.html"},
     {"title": "Utils.Leak.TLeakItem", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakItem.html"},
     {"title": "Utils.Leak.TLeakItem.New", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakItem.html#New"},
     {"title": "Utils.Leak.TLeakItem.Status", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakItem.html#Status"},
     {"title": "Utils.Leak.TLeakItem.Size", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakItem.html#Size"},
     {"title": "Utils.Leak.TLeakItem.Source", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakItem.html#Source"},
     {"title": "Utils.Leak.TLeakReport", "text": "&lt;sumary&gt; This class aims to interpret the memory leak trace file and produce a simpler report summarizing enough information to locate the problem at its source. )   ", "tags": "", "url": "Utils.Leak.TLeakReport.html"},
     {"title": "Utils.Leak.TLeakReport.Create", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#Create"},
     {"title": "Utils.Leak.TLeakReport.Destroy", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#Destroy"},
     {"title": "Utils.Leak.TLeakReport.New", "text": "    A valid instance of ICommandBuilder. Basically it will be used to generate the output to the console considering the theme settings.)    The path to the source code, needed to find the files corresponding to the source code reported in the memory leak trace file. )    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#New"},
     {"title": "Utils.Leak.TLeakReport.AddItem", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#AddItem"},
     {"title": "Utils.Leak.TLeakReport.CreateLeakItem", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#CreateLeakItem"},
     {"title": "Utils.Leak.TLeakReport.GetNextStringOf", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#GetNextStringOf"},
     {"title": "Utils.Leak.TLeakReport.AddRelativePath", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#AddRelativePath"},
     {"title": "Utils.Leak.TLeakReport.Output", "text": "    ", "tags": "", "url": "Utils.Leak.TLeakReport.html#Output"},
     {"title": "Utils.Leak.TLeakReport.ParseHeapTrace", "text": "   AContent Accepts the contents of the memory leak trace file. If an empty string is passed, the method will try to locate the heap.trc file in the test project's executable directory. AContent Accepts the contents of the memory leak trace file. If an empty string is passed, the method will try to locate the heap.trc file in the test project's executable directory. ", "tags": "", "url": "Utils.Leak.TLeakReport.html#ParseHeapTrace"},
     {"title": "Utils.Leak.TLeakReport.Executable", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakReport.html#Executable"},
     {"title": "Utils.Leak.TLeakReport.ProjectSource", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakReport.html#ProjectSource"},
     {"title": "Utils.Leak.TLeakReport.LeakData", "text": "   ", "tags": "", "url": "Utils.Leak.TLeakReport.html#LeakData"},
     {"title": "Utils.Output", "text": "   ", "tags": "", "url": "Utils.Output.html"},
     {"title": "Utils.Output.OutputInfo", "text": "       ATitle Title highlighted using the theme's Title color property AText information description without accent color, uses the theme's Other color property ATitle Title highlighted using the theme's Title color property AText information description without accent color, uses the theme's Other color property ", "tags": "", "url": "Utils.Output.html#OutputInfo"},
     {"title": "Utils.Output.OutputError", "text": "       ATitle Title highlighted using the theme's Title color property AText information description with accent color, uses the theme's Error color property ATitle Title highlighted using the theme's Title color property AText information description with accent color, uses the theme's Error color property ", "tags": "", "url": "Utils.Output.html#OutputError"},
     {"title": "Utils.Resources", "text": "   ", "tags": "", "url": "Utils.Resources.html"},
     {"title": "Utils.Resources.GetResource", "text": "    Resource name to get the string from )    ", "tags": "", "url": "Utils.Resources.html#GetResource"},
     {"title": "Utils.Shell", "text": "   ", "tags": "", "url": "Utils.Shell.html"},
     {"title": "Utils.Shell.TConsoleWatcher", "text": "   ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html"},
     {"title": "Utils.Shell.TConsoleWatcher.Create", "text": "       AProgram Program name or command to be executed. AParams Array of argumentos to be passed to the program or command being called AProgram Program name or command to be executed. AParams Array of argumentos to be passed to the program or command being called ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#Create"},
     {"title": "Utils.Shell.TConsoleWatcher.Destroy", "text": "    ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#Destroy"},
     {"title": "Utils.Shell.TConsoleWatcher.Execute", "text": "    ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#Execute"},
     {"title": "Utils.Shell.TConsoleWatcher.Stop", "text": "    ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#Stop"},
     {"title": "Utils.Shell.TConsoleWatcher.GetMessage", "text": "    ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#GetMessage"},
     {"title": "Utils.Shell.TConsoleWatcher.IsRunning", "text": "   ", "tags": "", "url": "Utils.Shell.TConsoleWatcher.html#IsRunning"},
     {"title": "Utils.Shell.MAX_BUFFER", "text": "   ", "tags": "", "url": "Utils.Shell.html#MAX_BUFFER"},
     {"title": "Utils.Shell.ShellCommand", "text": "       AProgram Program name or command to be executed. AParams Array of argumentos to be passed to the program or command being called AProgram Program name or command to be executed. AParams Array of argumentos to be passed to the program or command being called ", "tags": "", "url": "Utils.Shell.html#ShellCommand"},
     {"title": "Utils.Shell.TConsoleBuffer", "text": "   ", "tags": "", "url": "Utils.Shell.html#TConsoleBuffer"},
     {"title": "Utils.Shell.TShellCommandFunc", "text": "    ", "tags": "", "url": "Utils.Shell.html#TShellCommandFunc"},
     {"title": "Utils.Shell.ShellExecute", "text": "   ", "tags": "", "url": "Utils.Shell.html#ShellExecute"},
     {"title": "Utils.Tests", "text": "   ", "tags": "", "url": "Utils.Tests.html"},
     {"title": "Utils.Tests.TTestCaseItem", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html"},
     {"title": "Utils.Tests.TTestCaseItem.New", "text": "    ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#New"},
     {"title": "Utils.Tests.TTestCaseItem.Status", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#Status"},
     {"title": "Utils.Tests.TTestCaseItem.Time", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#Time"},
     {"title": "Utils.Tests.TTestCaseItem.TestSuite", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#TestSuite"},
     {"title": "Utils.Tests.TTestCaseItem.TestCase", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#TestCase"},
     {"title": "Utils.Tests.TTestCaseItem.Error", "text": "   ", "tags": "", "url": "Utils.Tests.TTestCaseItem.html#Error"},
     {"title": "Utils.Tests.TTestReport", "text": "&lt;sumary&gt; This class aims to interpret the fpcunit test xml file and produce a simpler report summarizing all tests cases and also providing their location on source code. )   ", "tags": "", "url": "Utils.Tests.TTestReport.html"},
     {"title": "Utils.Tests.TTestReport.Create", "text": "    ", "tags": "", "url": "Utils.Tests.TTestReport.html#Create"},
     {"title": "Utils.Tests.TTestReport.Destroy", "text": "    ", "tags": "", "url": "Utils.Tests.TTestReport.html#Destroy"},
     {"title": "Utils.Tests.TTestReport.New", "text": "    A valid instance of ICommandBuilder. Basically it will be used to generate the output to the console considering the theme settings.)    The path to the source code, needed to find the files corresponding to the source code reported in the fpcunit xml test file. )    ", "tags": "", "url": "Utils.Tests.TTestReport.html#New"},
     {"title": "Utils.Tests.TTestReport.ParseXmlTestsFile", "text": "       ATestApp Test application name that will be printed along with the test report output AFileName Unit test xml file generated by the test application ATestApp Test application name that will be printed along with the test report output AFileName Unit test xml file generated by the test application ", "tags": "", "url": "Utils.Tests.TTestReport.html#ParseXmlTestsFile"},
     {"title": "Utils.Tests.TTestReport.AddItem", "text": "   AItem The item to be added to TestCaseData AItem The item to be added to TestCaseData ", "tags": "", "url": "Utils.Tests.TTestReport.html#AddItem"},
     {"title": "Utils.Tests.TTestReport.Output", "text": "    ", "tags": "", "url": "Utils.Tests.TTestReport.html#Output"},
     {"title": "Utils.Tests.TTestReport.Executable", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#Executable"},
     {"title": "Utils.Tests.TTestReport.ProjectSource", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#ProjectSource"},
     {"title": "Utils.Tests.TTestReport.TestCaseCount", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TestCaseCount"},
     {"title": "Utils.Tests.TTestReport.TestSuiteCount", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TestSuiteCount"},
     {"title": "Utils.Tests.TTestReport.TotalTime", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TotalTime"},
     {"title": "Utils.Tests.TTestReport.TestsPassed", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TestsPassed"},
     {"title": "Utils.Tests.TTestReport.TestsFailed", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TestsFailed"},
     {"title": "Utils.Tests.TTestReport.TestCaseData", "text": "   ", "tags": "", "url": "Utils.Tests.TTestReport.html#TestCaseData"},
     {"title": "Utils.Watcher", "text": "   ", "tags": "", "url": "Utils.Watcher.html"},
     {"title": "Utils.Watcher.TPathWatcher", "text": "   ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html"},
     {"title": "Utils.Watcher.TPathWatcher.Create", "text": "    ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Create"},
     {"title": "Utils.Watcher.TPathWatcher.Destroy", "text": "    ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Destroy"},
     {"title": "Utils.Watcher.TPathWatcher.New", "text": "    ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#New"},
     {"title": "Utils.Watcher.TPathWatcher.Path", "text": "   APath Path that will be monitored APath Path that will be monitored ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Path"},
     {"title": "Utils.Watcher.TPathWatcher.Ignore", "text": "       AIgnoreKind Kind of item to be ignored by the watcher AItems An array containing strings to be ignored according to AIgnoreKind AIgnoreKind Kind of item to be ignored by the watcher AItems An array containing strings to be ignored according to AIgnoreKind ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Ignore"},
     {"title": "Utils.Watcher.TPathWatcher.Timeout", "text": "   ATime Number of milliseconds to set the maximum timeout. ATime Number of milliseconds to set the maximum timeout. ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Timeout"},
     {"title": "Utils.Watcher.TPathWatcher.Run", "text": "     )  AProc A procedure that will be called after a change AProc A procedure that will be called after a change ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Run"},
     {"title": "Utils.Watcher.TPathWatcher.Start", "text": "    ", "tags": "", "url": "Utils.Watcher.TPathWatcher.html#Start"},
     {"title": "Utils.Watcher.TDictFile", "text": "   ", "tags": "", "url": "Utils.Watcher.html#TDictFile"}
]};
